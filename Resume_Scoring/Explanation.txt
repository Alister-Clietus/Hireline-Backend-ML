üîπ 1. Overall Workflow of the Script
The script follows these main steps:

Extract Text & Fonts from PDF

Reads the resume using PyMuPDF.
Extracts all text and identifies font styles.
Preprocess Resume Text

Converts text to lowercase.
Removes special characters.
Uses spaCy for lemmatization (reducing words to their base form).
Load or Train Machine Learning Model

If a pre-trained model exists, load it.
If no model is found, train a new one using sample data.
Vectorize Resume Text

Convert text into numerical format using TF-IDF Vectorization.
Predict Resume Score

The trained SVR model predicts a score for the resume.
Check for Formatting Issues

Ensure consistent fonts (not more than 3).
Check if Skills & Technical Skills sections exist.
Analyze Margins & Padding.
Provide Suggestions for Improvement

Recommend missing skills based on industry standards.
Detect too many font styles or inconsistent margins.
üîπ 2. Machine Learning Model Used
üî∏ Model Type: Support Vector Regression (SVR)
The model used for resume scoring is Support Vector Regression (SVR).

Why SVR?

SVR is useful for predicting continuous values (like resume scores).
It works well with high-dimensional text data.
It finds a best-fit line that minimizes errors while ignoring outliers.
üîπ 3. Step-by-Step Explanation of Model Training
üî∏ Step 1: Data Preparation
To train a model, we need resume texts and corresponding scores.

Sample Data in Script
python
Copy
Edit
resume_texts = [
    "experienced python developer with machine learning knowledge",
    "entry-level software engineer, familiar with java",
    "senior data scientist with 10 years experience",
    "graphic designer proficient in adobe photoshop illustrator",
    "motion designer skilled in after effects premiere pro"
]
resume_scores = [9, 5, 10, 7, 8]
The dataset consists of sample resumes with predefined scores.
The scores range from 1 to 10.
üî∏ Step 2: Convert Text into Numerical Format (TF-IDF)
What is TF-IDF (Term Frequency-Inverse Document Frequency)?
TF-IDF is a method to convert text into numbers by measuring:

Term Frequency (TF): How often a word appears in a document.
Inverse Document Frequency (IDF): How unique the word is in the dataset.
Applying TF-IDF in the Script
python
Copy
Edit
vectorizer = TfidfVectorizer()
X = vectorizer.fit_transform(resume_texts)  # Convert text to numerical format
Each resume is converted into a numerical feature vector.
Common words like "the" and "is" are ignored.
üî∏ Step 3: Train the SVR Model
python
Copy
Edit
model = SVR(kernel="linear")
model.fit(X_train, y_train)
The Support Vector Regression (SVR) model is trained on the TF-IDF vectors.
The model learns to map text features to resume scores.
üî∏ Step 4: Predict Resume Score
Once trained, the model can predict a score for any new resume:

python
Copy
Edit
text_vector = vectorizer.transform([new_resume_text])
score = model.predict(text_vector)[0]
The new resume text is vectorized using the trained TF-IDF model.
The SVR model predicts a score between 1 and 10.
üîπ 4. Resume Analysis & Formatting Checks
üî∏ Checking for Key Sections
The script analyzes the resume for key sections:

"Skills" section must exist:
python
Copy
Edit
if "skills" not in resume_text:
    suggestions.append("üîπ Add a 'Skills' section to highlight your key competencies.")
"Technical Skills" section must exist:
python
Copy
Edit
if "technical skills" not in resume_text:
    suggestions.append("üîπ Add a 'Technical Skills' section for better clarity.")
üî∏ Checking Font Consistency
To ensure not too many font styles, the script collects all fonts:

python
Copy
Edit
fonts.add(span["font"])  # Store font styles used
If more than 3 font styles are found:

python
Copy
Edit
if len(fonts) > 3:
    suggestions.append(f"‚ö†Ô∏è Too many font styles detected ({len(fonts)}). Limit to 2-3 for consistency.")
üî∏ Checking Margins & Padding
To ensure text is properly aligned, the script detects text position:

python
Copy
Edit
for block in text_blocks:
    x0, y0, x1, y1 = block[:4]  # Get text block bounding box
    if x0 < 20 or x1 > page_width - 20 or y0 < 20 or y1 > page_height - 20:
        margin_issues += 1
If text is too close to the edges, a warning is added:

python
Copy
Edit
